#!/usr/bin/env python3

import json
import os
import sys
import termios
import tty


# TODO: Adopt curses framework for CLI apps


def update_dict(x, y):
    return {**x, **y}


#
# State manipulation tools
#


class State:
    """Program state

    """

    def __init__(self, name, workspace, users, bills):
        self.name = name
        self.workspace = workspace
        self.users = users
        self.bills = bills
        self.filepath = os.path.join(
            workspace, name + ".json"
        )

    def save(self):
        with open(self.filepath, "w+") as f:
            json.dump(self.__dict__, f)
        return

    @classmethod
    def load(cls, filepath):
        with open(filepath, "r") as f:
            raw = json.load(f)
        return cls(
            name=raw["name"],
            workspace=raw["workspace"],
            users=raw["users"],
            bills=raw["bills"]
        )


def calculate_balance(state) -> dict:
    """Calculate total balance from all events

    """
    total = {
        bill_id: sum([
            v[u]["payment"] for u in state.users
        ]) for (bill_id, v) in state.bills.items()
    }
    return {
        u: sum([
            (
                v[u]["payment"] -
                v[u]["share"] * total[bill_id]
            ) for (bill_id, v) in state.bills.items()
        ]) for u in state.users
    }


def calculate_flow(state):
    """Calculate suggested money flow

    The idea is to balance out with a minimal number of transactions.

    """

    def deduce(b):
        # Most indebted pays to most borrowd
        u_min = min(b, key=b.get)
        u_max = max(b, key=b.get)
        payment = min(abs(b[u_min]), abs(b[u_max]))
        return (u_min, u_max, payment)

    def pay(b, u_from, u_to, payment):
        # Update balance with one transaction
        return update_dict(b, {
            u_from: b[u_from] + payment,
            u_to: b[u_to] - payment
        })

    def flowflow(b, flow: list=[]):
        # Balance out until everybody at zero
        tract = deduce(b)
        return (
            flowflow(pay(b, *tract), flow + [tract])
            if max(b.values()) > 1e-6 else
            flow
        )

    return flowflow(calculate_balance(state))


#
# Command line tools
#


def clear():
    os.system("clear")


def _getch():
    """Get character and auto enter

    """
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch


def getch():
    """Get character, clear, and return

    """
    ch = _getch()
    clear()
    return ch


# TODO: Templating
#       - Support refresh hooks
# TODO: Flashing message to project_prompt (e.g. unknown key)
# TODO: Project summary to project_prompt
# TODO: All prompt views to same height


def _quit():
    clear()
    print(
        """

        Thanks for using Concourse!

        """
    )
    quit()


# Each of the actions perform some side-effects
# and passthrough (possibly) altered state.


def export_results(state):
    return state


def display_results(state):
    flow = calculate_flow(state)
    msg = "\n\t".join([
        "{0} --{1}--> {2}".format(
            u_from, round(payment, 2), u_to
        ) for (u_from, u_to, payment) in flow
    ])
    print(
        """

        *** Results ***

        <Key> Return to project menu


        {0}

        """.format(msg)
    )
    ch = getch()
    return state


def unknown(state):
    """Handle unknown selection

    """
    return state


def save(state):
    state.save()
    print("Saved as " + state.filepath)
    return state


def new_project():
    print(
        """

        *** New project ***

        """
    )
    name = input("Project name> ")
    workspace = input("Working directory> ")
    num = int(input("Number of users> "))
    users = [input("User #{0}> ".format(i + 1)) for i in range(num)]
    clear()
    return State(
        name=name,
        workspace=workspace,
        users=users,
        bills={}
    )


def load():
    print(
        """

        *** Load a project ***

        """
    )
    filepath = input("Filepath> ")
    return State.load(filepath)


def add_bill(state):
    print(
        """

        *** Add bill ***

        """
    )
    bill_id = input("Identifier> ")
    equal = input("Equal shares (y/n)> ")
    payments = {
        u: {
            "payment": float(input("{0} paid> ".format(u))),
            "share": (
                1.0 / len(state.users) if equal == "y" else
                0.01 * float(input("{0}'s percentage> ".format(u)))
            )
        } for u in state.users
    }
    bills = update_dict(
        state.bills,
        {bill_id: payments}
    )
    clear()
    return State(
        name=state.name,
        workspace=state.workspace,
        users=state.users,
        bills=bills
    )


def log_bills(state):
    # TODO: Log shares

    rf = "{:<12}" * (len(state.users) + 1)  # row format
    table = (
        rf.format("", *state.users) + "\n\t" +
        "\n\t".join([
            rf.format(bill_id, *[v[u]["payment"] for u in state.users])
            for (bill_id, v) in state.bills.items()
        ])
    )
    print(
        """

        *** Current bills ***

        <Key> Return to project menu


        {0}

        """.format(table)
    )
    ch = getch()
    return state


def display_balance(state):
    balance = calculate_balance(state)
    msg = "\n\t".join(
        [u + ": " + str(round(balance[u], 2)) for u in state.users]
    )
    print(
        """

        *** Current balance ***

        <Key> Return to project menu


        {0}

        """.format(msg)
    )
    ch = getch()
    return state


def project_prompt(state):
    # TODO: Pass optional message to main menu
    # TODO: Quit takes to main menu

    def do(ch, state):
        return project_prompt(
            add_bill(state)        if ch == "a" else
            display_balance(state) if ch == "b" else
            export_results(state)  if ch == "e" else
            log_bills(state)       if ch == "l" else
            display_results(state)   if ch == "r" else
            _quit()                if ch == "q" else
            save(state)            if ch == "s" else
            unknown(state)
        )

    print(
        """

        *** Project menu ***

        <a> Add bill
        <b> Display current balance
        <e> Export results
        <l> Log current bills
        <r> Display results
        <q> Quit
        <s> Save

        """
    )
    return do(getch(), state)


def main_prompt():

    def act(ch, state):
        return project_prompt(
            new_project()      if ch == "n" else
            load()             if ch == "l" else
            _quit()            if ch == "q" else
            unknown(state)
        )

    clear()
    print(
        """
           _____________________________________________
          ---------------------------------------------
         / Concourse -- Share costs and nothing more /
        ---------------------------------------------

        *** Main menu ***

        <n> Start a new project
        <l> Load an existing project
        <q> Quit

        """
    )
    return act(getch(), {})


if __name__ == "__main__":
    # TODO: CSV import as CLI argument
    # TODO: Load path as CLI argument
    # NOTE: Interactive UI only in Linux but CSV import everywhere
    main_prompt()
